{-# OPTIONS --sized-types --guardedness #-}

module Dynamical.Reservoir.ModeDependent where

open import Dynamical.System
open import Data.Product using (_√ó_; _,_)
open import Data.Sum
open import Data.Unit
open import Data.Nat renaming (_+_ to _+‚Ñï_)
open import Data.Float renaming (Float to ‚Ñù; tanh to tanh1) hiding (‚åä_‚åã)
open import CategoryData.Everything renaming (_*_ to _*p_ ; _+_ to _+p_; Y to Y')
open import Codata.Stream
open import Dynamical.Matrix.Everything as Matrix using (Matrix ; _*‚±Ω·¥π_ ; _*·¥π‚±Ω_ ; _*·¥π_ ; _+·¥π_ ; _+‚±Ω_ ; _·µÄ ; _‚Åª¬π ; _*À¢·¥π_ ; eye)
open import Dynamical.Reservoir.State
open import Dynamical.Lorenz as Lorenz
open import Data.Vec as Vec using (Vec ; map ; _‚à∑_)
open import Data.Bool using (if_then_else_ ; Bool)
open import Data.List using (List ; [] ; reverse)
open import Relation.Nullary.Decidable using (‚åä_‚åã)
open import Function
open import Level

import Category.Monad.Reader
open import Category.Monad

is-< : ‚Ñï ‚Üí ‚Ñï ‚Üí Bool
is-< a b = ‚åä a Data.Nat.<? b ‚åã

tanh : ‚àÄ {m n} ‚Üí Matrix ‚Ñù m n ‚Üí Matrix ‚Ñù m n
tanh = Matrix.map tanh1

data ReadoutOutput (numNodes systemDim : ‚Ñï) : Set where
  CD : ReadoutOutput numNodes systemDim
  R : Vec ‚Ñù systemDim ‚Üí OutputWeights numNodes systemDim ‚Üí List (ReservoirState numNodes) ‚Üí List (Vec ‚Ñù systemDim) ‚Üí ReadoutOutput numNodes systemDim

record CollectingDataInput (numNodes systemDim : ‚Ñï) : Set where
  constructor CDI
  field
    resStates : ReservoirState numNodes
    sysOutput : Vec ‚Ñù systemDim

record RunningInput (numNodes : ‚Ñï) : Set where
  constructor RI
  field
    resStates : ReservoirState numNodes

DependentInput : {numNodes systemDim : ‚Ñï} ‚Üí ReadoutOutput numNodes systemDim ‚Üí Set
DependentInput {numNodes} {systemDim} CD = CollectingDataInput numNodes systemDim
DependentInput {numNodes} (R _ _ _ _) = RunningInput numNodes

reservoir : (numNodes systemDim : ‚Ñï) ‚Üí DynamicalSystem
reservoir numNodes systemDim = MkDynamicalSystem (ReservoirState numNodes) interface (readout ‚áÜ update)
  where interface : Polynomial
        interface = mkpoly (ReservoirState numNodes) Œª _ ‚Üí Vec ‚Ñù systemDim √ó InputWeights numNodes systemDim √ó ReservoirWeights numNodes
        readout : ReservoirState numNodes ‚Üí ReservoirState numNodes
        readout = id
        update : ReservoirState numNodes ‚Üí Vec ‚Ñù systemDim √ó InputWeights numNodes systemDim √ó ReservoirWeights numNodes ‚Üí ReservoirState numNodes
        update (Res nodeStates) (inputSequence , inputWeights , reservoirWeights) = Res reservoirActivations
           where inputDynamic : Vec ‚Ñù numNodes
                 inputDynamic = inputWeights *·¥π‚±Ω inputSequence
                 newReservoirStates : Vec ‚Ñù numNodes
                 newReservoirStates = reservoirWeights *·¥π‚±Ω nodeStates
                 reservoirActivations : Vec ‚Ñù numNodes
                 reservoirActivations = Vec.map tanh1 (newReservoirStates +‚±Ω inputDynamic)

readoutLayer : (numNodes systemDim trainingSteps : ‚Ñï) ‚Üí DynamicalSystem
readoutLayer numNodes systemDim trainingSteps = MkDynamicalSystem (ReadoutLayerState numNodes systemDim) interface (readout ‚áÜ update)
  where interface : Polynomial
        interface = mkpoly (ReadoutOutput numNodes systemDim) DependentInput
        readout : ReadoutLayerState numNodes systemDim ‚Üí ReadoutOutput numNodes systemDim
        readout (Coll _) = CD -- don't care when training
        readout (Run (Running outputWeights (Res nodeStates) statesHist systemHist)) = R (outputWeights ·µÄ *·¥π‚±Ω nodeStates) outputWeights (reverse statesHist) (reverse systemHist)
        update : (fromPos : ReadoutLayerState numNodes systemDim) ‚Üí DependentInput (readout fromPos) ‚Üí ReadoutLayerState numNodes systemDim
        update (Coll (Collecting counter statesHistory systemHistory)) (CDI newNodeStates systemOutput) = 
          if is-< counter trainingSteps then keepCollecting else trainThenRun
            where statesHist : Matrix ‚Ñù counter numNodes
                  statesHist = Matrix.ùïÑ $ Vec.reverse (Vec.map ReservoirState.nodeStates statesHistory)
                  systemHist : Matrix ‚Ñù counter systemDim
                  systemHist = Matrix.ùïÑ $ Vec.reverse systemHistory
                  ridge = 0.01
            
                  keepCollecting : ReadoutLayerState numNodes systemDim
                  keepCollecting = Coll (Collecting (1 +‚Ñï counter) (newNodeStates ‚à∑ statesHistory) (systemOutput ‚à∑ systemHistory))
                  trainThenRun : ReadoutLayerState numNodes systemDim
                  trainThenRun = Run (Running trainedOutput initialState (Vec.toList statesHistory) (Vec.toList systemHistory))
                    where initialState : ReservoirState numNodes
                          initialState = Res (Vec.replicate 0.0)
                          trainedOutput : OutputWeights numNodes systemDim
                          trainedOutput = (statesHist ·µÄ *·¥π statesHist +·¥π ridge *À¢·¥π eye)‚Åª¬π *·¥π (statesHist ·µÄ *·¥π systemHist) 
          
        update (Run (Running outputWeights reservoirState sth ssh)) (RI resStates) = Run (Running outputWeights resStates sth ssh)

preLorRes : (numNodes trainingSteps : ‚Ñï) ‚Üí (dt : ‚Ñù) ‚Üí InputWeights numNodes 3 ‚Üí ReservoirWeights numNodes ‚Üí DynamicalSystem
preLorRes numNodes trainingSteps dt inputWeights reservoirWeights = 
  lorenz dt &&& reservoir numNodes 3 &&& readoutLayer numNodes 3 trainingSteps

OuterOutputType : (numNodes : ‚Ñï) ‚Üí  Set
OuterOutputType numNodes = ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó OutputWeights numNodes 3 √ó List (ReservoirState numNodes) √ó List (Vec ‚Ñù 3) ‚äé ‚ä§

OuterOutput : (numNodes : ‚Ñï) ‚Üí Polynomial
OuterOutput numNodes = Emitter (OuterOutputType numNodes)


lorenzReservoirWiringDiagram :
  (numNodes : ‚Ñï) ‚Üí
  (inputWeights : InputWeights numNodes 3) ‚Üí
  (reservoirWeights : ReservoirWeights numNodes) ‚Üí
   Lens 
    (DynamicalSystem.interface (preLorRes numNodes 3 0.0 inputWeights reservoirWeights))
    (OuterOutput numNodes)
lorenzReservoirWiringDiagram numNodes inputWeights reservoirWeights = outerOutputsFrom ‚áÜ innerInputsFrom
  where outerOutputsFrom : position
                           (DynamicalSystem.interface (preLorRes numNodes 3 0.0 inputWeights reservoirWeights)) ‚Üí
                           position (OuterOutput numNodes)
        outerOutputsFrom ((xnt x , ynt y , znt z) , res , R (predx Vec.‚à∑ predy Vec.‚à∑ predz Vec.‚à∑ Vec.[]) ow stateHist sysHis) = inj‚ÇÅ (x , (y , (z , (predx , (predy , (predz , (ow , (stateHist , sysHis))))))))
        outerOutputsFrom (lor , res , CD) = inj‚ÇÇ tt
        innerInputsFrom : (fromPos : position (DynamicalSystem.interface (preLorRes numNodes 3 0.0 (Matrix.replicate 1.0) (Matrix.replicate 1.0)))) ‚Üí
                          direction (OuterOutput numNodes) (outerOutputsFrom fromPos) ‚Üí
                          direction (DynamicalSystem.interface (preLorRes numNodes 3 0.0 inputWeights reservoirWeights))
                          fromPos
        innerInputsFrom (lorOutput , resOutput , R readOutput ow sh sl) dir = tt , resInputRunning , readInputRunning
          where resInputRunning : direction (DynamicalSystem.interface (reservoir numNodes 3)) resOutput
                resInputRunning = readOutput , inputWeights , reservoirWeights
                readInputRunning : RunningInput numNodes
                readInputRunning = RI resOutput
        innerInputsFrom (lorOutput , resOutput , CD) dir = tt , resInputTraining , CDI resOutput (outToVec lorOutput)
           where resInputTraining : direction (DynamicalSystem.interface (reservoir numNodes 3)) resOutput
                 resInputTraining = Lorenz.outToVec lorOutput , inputWeights , reservoirWeights
                 readInputTraining : ReservoirState numNodes
                 readInputTraining = resOutput
data RestartOrContinue : Set where
  continue : X √ó Y √ó Z ‚Üí RestartOrContinue
  restart : X √ó Y √ó Z ‚Üí RestartOrContinue
restartingLorenz : ‚Ñù ‚Üí DynamicalSystem
restartingLorenz dt = MkDynamicalSystem (DynamicalSystem.state (lorenz dt) ‚äé X √ó Y √ó Z) interface behavior
  where interface : Polynomial
        interface = mkpoly RestartOrContinue Œª { (continue _) ‚Üí ‚ä§ ; (restart _) ‚Üí X √ó Y √ó Z }
        behavior : Lens (selfMonomial (DynamicalSystem.state (lorenz dt) ‚äé X √ó Y √ó Z)) interface
        behavior = readout ‚áÜ update
           where readout : X √ó Y √ó Z ‚äé X √ó Y √ó Z  ‚Üí RestartOrContinue
                 readout (inj‚ÇÅ x‚ÇÅ) = continue x‚ÇÅ
                 readout (inj‚ÇÇ lastInputState) = restart lastInputState
                 update : (fromPos : X √ó Y √ó Z ‚äé X √ó Y √ó Z) ‚Üí direction interface (readout fromPos) ‚Üí X √ó Y √ó Z ‚äé X √ó Y √ó Z
                 update (inj‚ÇÅ x‚ÇÅ) tt = {!   !}
                 update (inj‚ÇÇ y‚ÇÅ) inp = {!   !}

lorenzReservoir : 
  (numNodes : ‚Ñï) ‚Üí
  (trainingSteps : ‚Ñï) ‚Üí
  (dt : ‚Ñù) ‚Üí
  (inputWeights : InputWeights numNodes 3) ‚Üí
  (reservoirWeights : ReservoirWeights numNodes) ‚Üí 
  DynamicalSystem
lorenzReservoir numNodes trainingSteps dt inputWeights reservoirWeights = 
  install (preLorRes numNodes trainingSteps dt inputWeights reservoirWeights) 
          (OuterOutput numNodes)
          (lorenzReservoirWiringDiagram numNodes inputWeights reservoirWeights)

    
lorenzResSeq : 
  (numNodes : ‚Ñï) ‚Üí
  (trainingSteps : ‚Ñï) ‚Üí
  (lorenzInitialConditions : ‚Ñù √ó ‚Ñù √ó ‚Ñù ) ‚Üí
  (dt : ‚Ñù) ‚Üí
  (inputWeights : InputWeights numNodes 3) ‚Üí
  (reservoirWeights : ReservoirWeights numNodes) ‚Üí 
  Stream (OuterOutputType numNodes) _
lorenzResSeq numNodes trainingSteps ( ix , iy , iz ) dt inputWeights reservoirWeights = 
  run (lorenzReservoir numNodes trainingSteps dt inputWeights reservoirWeights)
      auto
      ((xnt ix , ynt iy , znt iz) , (Res (Vec.replicate 0.0)) , Coll (Collecting 0 Vec.[] Vec.[]))

lorenzResList : 
  (numNodes : ‚Ñï) ‚Üí
  (trainingSteps : ‚Ñï) ‚Üí
  (totalSequenceSteps : ‚Ñï) ‚Üí
  (lorenzInitialConditions : ‚Ñù √ó ‚Ñù √ó ‚Ñù) ‚Üí
  (dt : ‚Ñù)
  (inputWeights : InputWeights numNodes 3) ‚Üí
  (reservoirWeights : ReservoirWeights numNodes) ‚Üí 
  Vec (‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó OutputWeights numNodes 3 √ó List (ReservoirState numNodes) √ó List (Vec ‚Ñù 3)) totalSequenceSteps
lorenzResList numNodes trainingSteps totalSequenceSteps lorenzInitialConditions dt inputWeights reservoirWeights = 
    Vec.map discr (take totalSequenceSteps $ lorenzResSeq numNodes trainingSteps lorenzInitialConditions dt inputWeights reservoirWeights)
       where discr : OuterOutputType numNodes ‚Üí (‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó OutputWeights numNodes 3 √ó List (ReservoirState numNodes) √ó List (Vec ‚Ñù 3))
             discr (inj‚ÇÅ x) = x
             discr (inj‚ÇÇ tt) = 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , Matrix.ùïÑ (Vec.replicate (Vec.replicate 0.0)) , [] , []
  