{-# OPTIONS --sized-types --guardedness #-}

module Dynamical.Reservoir.ModeDependent where

open import Dynamical.System
open import Data.Product using (_√ó_; _,_)
open import Data.Sum
open import Data.Unit
open import Data.Nat renaming (_+_ to _+‚Ñï_)
open import Data.Float renaming (Float to ‚Ñù; tanh to tanh1; show to showf) hiding (‚åä_‚åã)
open import CategoryData.Everything renaming (_*_ to _*p_ ; _+_ to _+p_; Y to Y')
open import Codata.Stream using (Stream ; take ; drop)
open import Dynamical.Matrix.Everything as Matrix using (Matrix ; _*‚±Ω·¥π_ ; _*·¥π‚±Ω_ ; _*·¥π_ ; _+·¥π_ ; _+‚±Ω_ ; _·µÄ ; _‚Åª¬π ; _*À¢·¥π_ ; eye)
open import Dynamical.Reservoir.State
open import Dynamical.Lorenz as Lorenz
open import Data.Vec as Vec using (Vec ; map ; _‚à∑_)
open import Data.Bool using (if_then_else_ ; Bool)
open import Data.List using (List ; [] ; reverse)
open import Relation.Nullary.Decidable using (‚åä_‚åã)
open import Function
open import Level
open DynamicalSystem renaming (interface to interface‚Çö)
open ReservoirState
open import Data.Bool

import Category.Monad.Reader
open import Category.Monad

is-< : ‚Ñï ‚Üí ‚Ñï ‚Üí Bool
is-< a b = ‚åä a Data.Nat.<? b ‚åã

is-‚â° : ‚Ñï ‚Üí ‚Ñï ‚Üí Bool
is-‚â° a b = ‚åä a Data.Nat.‚âü b ‚åã

tanh : ‚àÄ {m n} ‚Üí Matrix ‚Ñù m n ‚Üí Matrix ‚Ñù m n
tanh = Matrix.map tanh1

open import Data.String
postulate trace : ‚àÄ {A : Set} ‚Üí String ‚Üí A ‚Üí A
{-# FOREIGN GHC
  import Debug.Trace
  import Data.Text

  myTrace :: Text -> a -> a
  myTrace str a = trace (unpack str) a
#-}
{-# COMPILE GHC trace = \_ -> myTrace #-}

data ReadoutOutput (numNodes systemDim : ‚Ñï) : Set where
  CD : ReadoutOutput numNodes systemDim
  R : Vec ‚Ñù systemDim ‚Üí ReadoutOutput numNodes systemDim

record CollectingDataInput (numNodes systemDim : ‚Ñï) : Set where
  constructor CDI
  field
    resStates : ReservoirState numNodes
    sysOutput : Vec ‚Ñù systemDim

RunningInput : (numNodes : ‚Ñï) ‚Üí Set
RunningInput = ReservoirState

DependentInput : {numNodes systemDim : ‚Ñï} ‚Üí ReadoutOutput numNodes systemDim ‚Üí Set
DependentInput {numNodes} {systemDim} CD = CollectingDataInput numNodes systemDim
DependentInput {numNodes} (R _ ) = RunningInput numNodes

reservoir : (numNodes systemDim : ‚Ñï) ‚Üí DynamicalSystem
reservoir numNodes systemDim = mkdyn (ReservoirState numNodes) interface (readout ‚áÜ update)
  where interface : Polynomial
        interface = mkpoly (ReservoirState numNodes) Œª _ ‚Üí Vec ‚Ñù systemDim √ó InputWeights numNodes systemDim √ó ReservoirWeights numNodes √ó Bool
        readout : ReservoirState numNodes ‚Üí ReservoirState numNodes
        readout = id
        update : ReservoirState numNodes ‚Üí Vec ‚Ñù systemDim √ó InputWeights numNodes systemDim √ó ReservoirWeights numNodes √ó Bool ‚Üí ReservoirState numNodes
        update (Res nodes) (inputSequence , inputWeights , _ , true) =
          Res reservoirActivations
          where reservoirActivations = (Vec.replicate 0.0)
        update (Res nodeStates) (inputSequence , inputWeights , reservoirWeights , _) =
          Res reservoirActivations
          where inputDynamic : Vec ‚Ñù numNodes
                inputDynamic = inputWeights *·¥π‚±Ω inputSequence
                newReservoirStates : Vec ‚Ñù numNodes
                newReservoirStates = reservoirWeights *·¥π‚±Ω nodeStates
                reservoirActivations : Vec ‚Ñù numNodes
                reservoirActivations = Vec.map tanh1 (newReservoirStates +‚±Ω inputDynamic)

readoutLayer : (numNodes systemDim trainingSteps : ‚Ñï) ‚Üí DynamicalSystem
readoutLayer numNodes systemDim trainingSteps = mkdyn (ReadoutLayerState numNodes systemDim) interface (readout ‚áÜ update)
  where interface : Polynomial
        interface = mkpoly (ReadoutOutput numNodes systemDim) DependentInput
        readout : ReadoutLayerState numNodes systemDim ‚Üí ReadoutOutput numNodes systemDim
        readout (Coll _) = CD -- don't care when training
        readout (Run (Running outputWeights (Res lastSeenNodeStates))) = R (outputWeights ·µÄ *·¥π‚±Ω lastSeenNodeStates)
        update : (fromPos : ReadoutLayerState numNodes systemDim) ‚Üí DependentInput (readout fromPos) ‚Üí ReadoutLayerState numNodes systemDim
        update (Coll (Collecting counter statesHistory systemHistory)) (CDI newNodeStates systemOutput) = 
          if is-< counter trainingSteps then keepCollecting else trainThenRun
            where statesHist : Matrix ‚Ñù counter numNodes
                  statesHist = Matrix.ùïÑ $ Vec.reverse (Vec.map ReservoirState.nodeStates statesHistory)
                  systemHist : Matrix ‚Ñù counter systemDim
                  systemHist = Matrix.ùïÑ $ Vec.reverse systemHistory
                  ridge = 0.01
                  keepCollecting : ReadoutLayerState numNodes systemDim
                  keepCollecting = Coll (Collecting (1 +‚Ñï counter) (newNodeStates ‚à∑ statesHistory) (systemOutput ‚à∑ systemHistory))
                  trainThenRun : ReadoutLayerState numNodes systemDim
                  trainThenRun = Run (Running trainedOutputWeights initialState)
                    where initialState : ReservoirState numNodes
                          initialState = Res (Vec.replicate 0.0)
                          trainedOutputWeights : OutputWeights numNodes systemDim
                          trainedOutputWeights = (statesHist ·µÄ *·¥π statesHist +·¥π ridge *À¢·¥π eye {n = numNodes})‚Åª¬π *·¥π (statesHist ·µÄ *·¥π systemHist)
        update (Run (Running outputWeights (Res lastSeenNodeStates))) (Res nodeStateFromReservoir) = 
          Run (Running outputWeights (Res nodeStateFromReservoir))

data TouchCtrl : Set where
  touching : ‚Ñï ‚Üí TouchCtrl
  going : ‚Ñï ‚Üí TouchCtrl
ctr : {numNodes systemDim : ‚Ñï} ‚Üí ‚Ñï ‚Üí DynamicalSystem
ctr {nN} {sd} touchSteps = mkdyn ‚Ñï (mkpoly TouchCtrl (Œª x‚ÇÅ ‚Üí ReadoutOutput nN sd)) (crossThreshold ‚áÜ countUp)
  where crossThreshold : ‚Ñï ‚Üí TouchCtrl
        crossThreshold st = 
          if is-< st touchSteps then 
            touching st else 
            going st
        countUp : ‚Ñï ‚Üí ReadoutOutput nN sd ‚Üí ‚Ñï
        countUp st CD = st
        countUp st (R _) = st +‚Ñï 1



preLorRes : (numNodes trainingSteps touchSteps : ‚Ñï) ‚Üí (dt : ‚Ñù) ‚Üí InputWeights numNodes 3 ‚Üí ReservoirWeights numNodes ‚Üí DynamicalSystem
preLorRes numNodes trainingSteps touchSteps dt inputWeights reservoirWeights = 
  -- Training system
  lorenz dt &&& 
  -- Test system
  canResetLorenz dt &&&
  -- Counter controlling wiring pattern
  ctr {numNodes} {3} touchSteps  &&&
  -- Reservoir of dynamics
  reservoir numNodes 3 &&&
  -- Readout layer
  readoutLayer numNodes 3 trainingSteps
OuterOutputType : (numNodes : ‚Ñï) ‚Üí  Set
OuterOutputType numNodes = ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù ‚äé ‚ä§

OuterOutput : (numNodes : ‚Ñï) ‚Üí Polynomial
OuterOutput numNodes = emitter (OuterOutputType numNodes)


outerOutputsFrom : {numNodes : ‚Ñï} {inputWeights : InputWeights numNodes 3} {reservoirWeights : ReservoirWeights numNodes} ‚Üí
        position (interface‚Çö (preLorRes numNodes 3 3 0.0 inputWeights reservoirWeights)) ‚Üí
        position (OuterOutput numNodes)
-- When collecting data, the outermost box's output doesn't matter 
outerOutputsFrom (_ , _ , _ , _ , CD) = inj‚ÇÇ tt
-- When touching AND trained, we want to give the test output + the readout's
-- prediction as output. The readout's prediction shouldn't be very meaningful yet.
outerOutputsFrom (_ ,                                -- lorTrainOutput
                 (xnt x , ynt y , znt z) ,           -- lorTestOutput
                 touching _ ,                        -- touchController output
                 _ ,                                 -- reservoir output
                 R (predx ‚à∑ predy ‚à∑ predz ‚à∑ Vec.[])) -- readout layer output
    = inj‚ÇÅ (x , y , z , predx , predy , predz)
-- When GOING and trained, we want the same output. The readout's prediction should
-- now slowly start creating distance 
outerOutputsFrom (_ ,                                 -- lorTrainOutput
                 (xnt x , ynt y , znt z) ,            -- lorTestOutput
                 going _ ,                            -- touchController output
                 _ ,                                  -- reservoir output
                 R (predx ‚à∑ predy ‚à∑ predz ‚à∑ Vec.[]))  -- readout layer output
    = inj‚ÇÅ (x , y , z , predx , predy , predz)

lorenzReservoirWiringDiagram :
  (numNodes : ‚Ñï) ‚Üí
  (inputWeights : InputWeights numNodes 3) ‚Üí
  (reservoirWeights : ReservoirWeights numNodes) ‚Üí
   Lens 
    (interface‚Çö (preLorRes numNodes 3 3 0.0 inputWeights reservoirWeights))
    (OuterOutput numNodes)
lorenzReservoirWiringDiagram numNodes inputWeights reservoirWeights = 
        outerOutputsFrom {inputWeights = inputWeights} {reservoirWeights = reservoirWeights} 
        ‚áÜ 
        innerInputsFrom
  where 
        innerInputsFrom : 
          (fromPos : (X √ó Y √ó Z) √ó                 -- lorTrainOutput
                     (X √ó Y √ó Z) √ó                 -- lorTestOutput
                     TouchCtrl √ó                   -- touchCtrller output
                     (ReservoirState numNodes) √ó   -- reservoir output
                     (ReadoutOutput numNodes 3)) ‚Üí -- readout layer output
           ‚ä§ ‚Üí                                     -- input to outer box 
          (direction (interface‚Çö (preLorRes numNodes 3 3 0.0 inputWeights reservoirWeights)) fromPos)
        -- When touching zero AND readout is trained
        innerInputsFrom (_ , 
                        lorTestOutput , 
                        touching zero , 
                        resOutput , 
                        ro@(R readOutput )
                        ) dir = 
              tt ,                                      -- always tt for lorenz training
              inj‚ÇÇ (xnt 4.0 , ynt 4.0 , znt 4.0) ,      -- reset test with 4.0 4.0 4.0
              ro ,                                      -- always readout output to touchController
              (
                Lorenz.outToVec (xnt 4.0 , ynt 4.0 , znt 4.0) , -- reservoir gets: DOESNT MATTER because will be reset
                inputWeights ,                                  -- input and
                reservoirWeights ,                              -- reservoir weights as usual
                true                                            -- TRUE for the reset
              ) ,
              resOutput
        -- When touching > zero AND readout is trained
        innerInputsFrom (_ , 
                        lorTestOutput , 
                        touching ctrVal , 
                        resOutput , 
                        ro@(R readOutput)) dir = 
              tt ,                                      -- always tt for lorenz training
              inj‚ÇÅ tt ,                                 -- do not rest lorenz test
              ro ,                                      -- always readout output to touchController
              (Lorenz.outToVec lorTestOutput ,                 -- reservoir gets: TEST output
                               inputWeights ,                  -- input and
                               reservoirWeights ,              -- reservoir weights as usual
                               false) ,                        -- FALSE for the reset. keep what it has
              resOutput
        -- When going AND readout is trained
        innerInputsFrom (_ , 
                         _ , 
                         going ctrVal , 
                         resOutput , 
                         ro@(R readOutput)) dir = 
              tt ,                                      -- always tt for lorenz training
              inj‚ÇÅ tt ,                                 -- do not rest lorenz test
              ro ,                                      -- always readout output to touchController
              (
                readOutput ,                 -- reservoir gets: THE READOUT output
                inputWeights ,               -- input and
                reservoirWeights ,           -- reservoir weights as usual
                false                        -- FALSE for the reset. keep what it has
              ) , 
              resOutput
        -- When TRAINING / COLLECTING DATA
        innerInputsFrom (lorTrainingOutput , 
                        _ , 
                        _ , 
                        resOutput ,
                        CD) dir = 
                        tt , 
                        inj‚ÇÅ tt , 
                        CD , 
                        (
                          Lorenz.outToVec lorTrainingOutput , 
                          inputWeights , 
                          reservoirWeights , 
                          false
                        ) , 
                        CDI resOutput (outToVec lorTrainingOutput)
           where resInputTraining : direction (interface‚Çö (reservoir numNodes 3)) resOutput
                 resInputTraining = Lorenz.outToVec lorTrainingOutput , inputWeights , reservoirWeights , false

lorenzReservoir : 
  (numNodes : ‚Ñï) ‚Üí
  (trainingSteps : ‚Ñï) ‚Üí
  (touchSteps : ‚Ñï) ‚Üí
  (dt : ‚Ñù) ‚Üí
  (inputWeights : InputWeights numNodes 3) ‚Üí
  (reservoirWeights : ReservoirWeights numNodes) ‚Üí 
  DynamicalSystem
lorenzReservoir numNodes trainingSteps touchSteps dt inputWeights reservoirWeights = 
  install (preLorRes numNodes trainingSteps touchSteps dt inputWeights reservoirWeights) 
          (OuterOutput numNodes)
          (lorenzReservoirWiringDiagram numNodes inputWeights reservoirWeights)

lorenzResSeq :
  (numNodes : ‚Ñï) ‚Üí
  (trainingSteps : ‚Ñï) ‚Üí
  (touchSteps : ‚Ñï) ‚Üí
  (lorenzInitialConditions : ‚Ñù √ó ‚Ñù √ó ‚Ñù ) ‚Üí
  (dt : ‚Ñù) ‚Üí
  (inputWeights : InputWeights numNodes 3) ‚Üí
  (reservoirWeights : ReservoirWeights numNodes) ‚Üí 
  Stream (OuterOutputType numNodes) _
lorenzResSeq numNodes trainingSteps touchSteps ( ix , iy , iz ) dt inputWeights reservoirWeights = 
  run (lorenzReservoir numNodes trainingSteps touchSteps dt inputWeights reservoirWeights)
      auto
      ((xnt ix , ynt iy , znt iz) , ((xnt (ix + 3.0) , ynt (iy + 3.0) , znt (iz + 3.0))) , 0 , (Res (Vec.replicate 0.0)) , Coll (Collecting 0 Vec.[] Vec.[]))

lorenzResList : 
  (numNodes : ‚Ñï) ‚Üí
  (trainingSteps : ‚Ñï) ‚Üí
  (touchSteps : ‚Ñï) ‚Üí
  (outputLength : ‚Ñï) ‚Üí
  (lorenzInitialConditions : ‚Ñù √ó ‚Ñù √ó ‚Ñù) ‚Üí
  (dt : ‚Ñù)
  (inputWeights : InputWeights numNodes 3) ‚Üí
  (reservoirWeights : ReservoirWeights numNodes) ‚Üí 
  Vec (‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù) outputLength
lorenzResList numNodes trainingSteps touchSteps outputLength lorenzInitialConditions dt inputWeights reservoirWeights = 
    Vec.map discr (take outputLength ‚àò drop (trainingSteps +‚Ñï touchSteps) $ lorenzResSeq numNodes trainingSteps touchSteps lorenzInitialConditions dt inputWeights reservoirWeights)
       where discr : OuterOutputType numNodes ‚Üí (‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù √ó ‚Ñù)
             discr (inj‚ÇÅ x) = x
             discr (inj‚ÇÇ tt) = 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 
   